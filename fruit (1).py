# -*- coding: utf-8 -*-
"""fruit.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16ZKBMZG6tvDQ3At4GGAayhRWb6lltSvu
"""

! pip install keras

"""Plant Disease Identification"""

import os                       # for working with files
import numpy as np
import pandas as pd
import pickle
from keras import backend as K
#from keras.optimizers import Adam
from keras.preprocessing import image
#from keras.preprocessing.image import img_to_array
#from keras.preprocessing.image import MultiLabelBinarizer
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt

!zip -FF /content/Fertilizers_Recommendation_ System_For_Disease_ Prediction.zip

from zipfile import ZipFile
with ZipFile("/content/Fertilizers_Recommendation_ System_For_Disease_ Prediction.zip", 'r') as zip:
  zip.extractall()
  print('Done!')



pwd

"""image augumentation"""

from tensorflow.keras.preprocessing.image import ImageDataGenerator

train_datagen=ImageDataGenerator(rescale=1./255, shear_range=0.2,zoom_range=0.2,
                                 horizontal_flip=True)
test_datagen=ImageDataGenerator(rescale=1)

x_train=train_datagen.flow_from_directory("Dataset Plant Disease/Veg-dataset/Veg-dataset/train_set",
                                          target_size= (128,128), batch_size=32,class_mode= 'categorical')
x_test=test_datagen.flow_from_directory('Dataset Plant Disease/Veg-dataset/Veg-dataset/test_set',
                                          target_size= (128,128), batch_size=32,class_mode= 'categorical')

zip_ref.printdir()

x_train.class_indices

from keras.models import Sequential
from keras.layers import Convolution2D
from keras.layers import MaxPooling2D
from keras.layers import Activation, Flatten, Dropout, Dense

model=Sequential()
model.add(Convolution2D(32,(3,3),input_shape= (128,128,3),activation='relu'))
model.add(MaxPooling2D(pool_size= (2,2)))
model.add(Flatten())
model.add(Dense(units = 40, activation = 'relu'))
model.add(Dense(units=20, activation = 'relu'))
model.add(Dense(units=9, activation = 'softmax'))
#classifier.add(Dense(6, activation='relu', kernel_initializer='glorot_uniform',input_dim=11))



model.summary()



model.compile(loss= 'categorical_crossentropy', optimizer= 'adam', metrics= ['accuracy'])

len(x_train)

model.fit(x_train,steps_per_epoch=len(x_train),validation_steps=len(x_test),epochs=1)
#model.fit(x_train, epochs=5, validation_data=x_test)

model.save('vegetable.h5')

from keras.preprocessing import image
from tensorflow.keras.preprocessing.image import img_to_array
from tensorflow.keras.models import load_model
import numpy as np

model= load_model('vegetable.h5')



img=image.load_img("/content/00fca0da-2db3-481b-b98a-9b67bb7b105c___RS_HL 7708.JPG", target_size= (128,128))

x= image.img_to_array(img)

x=np.expand_dims(x,axis=0)

pred = model.predict(x)

pred

from tensorflow.keras.layers import Input
from tensorflow.keras.models import Model
from tensorflow.keras.applications import VGG19
import tensorflow as tf
baseModel = VGG19 (weights="imagenet", include_top= False, input_tensor=Input(shape=(128,128,3)))
headModel= baseModel.output
headModel= tf.keras.layers.AveragePooling2D (pool_size=(3,3))(headModel)
headModel= tf.keras.layers.Flatten(name="flatten")(headModel)
headModel= tf.keras.layers.Dense(512, activation="relu")(headModel)
headModel=tf.keras.layers.Dropout(0.5)(headModel)
headModel = tf.keras.layers.Dense(6,activation="softmax")(headModel)
model= Model(inputs=baseModel.input,outputs=headModel)

model.summary()

for baseModellayers in baseModel.layers:
        baseModellayers.trainable=False

from tensorflow.keras.optimizers import SGD
opt =SGD(learning_rate=0.0001, momentum=0.9)

from tensorflow.keras.callbacks import History

history = History()
History = model.fit(
    #trainingAugmentation.flow(X_train,Y_train, batch_size=64),
    X_train,Y_train, batch_size=64,
    steps_per_epoch = len(X_train) // 64,
    #steps_per_epoch = 50,
    #validation_data= validationAugmentation.flow(X_test,Y_test),
    validation_data= (X_test,Y_test),
    #validation_steps=50,
    validation_steps=len(X_test) // 64,
    epochs=400,
    callbacks=[history])

from tensorflow.keras.callbacks import History

history = History()
History = model.fit(
    #trainingAugmentation.flow(X_train,Y_train, batch_size=64),
    x_train, batch_size=64,
    steps_per_epoch = len(x_train) // 64,
    #steps_per_epoch = 50,
    #validation_data= validationAugmentation.flow(X_test,Y_test),
    validation_data= (x_test),
    #validation_steps=50,
    validation_steps=len(x_test) // 64,
    epochs=1,
    callbacks=[history])

plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('Model Loss')
plt.ylabel('Loss')
plt.xlabel('Epoch')
plt.legend(['train','test'],loc='upper left')
plt.show()

model.evaluate(X_test,Y_test)

from sklearn.metrics import confusion_matrix, classification_report
import seaborn as sns
y_pred=model.predict(X_test)
y_pred = np.argmax(y_pred, axis=1)
y_test = np.argmax(Y_test, axis=1)
cm=confusion_matrix(y_test, y_pred)
fig, ax = plt.subplots(figsize=(5,4))
sns.heatmap(cm, linewidths=1, annot=True, ax=ax, fmt='g',cmap="crest")

from sklearn.metrics import confusion_matrix, classification_report
y_pred=model.predict(X_test)
y_pred = np.argmax(y_pred, axis=1)
y_test = np.argmax(Y_test, axis=1)
cm=confusion_matrix(y_test, y_pred)
cm

print(classification_report(y_test,y_pred))

from sklearn.metrics import precision_recall_curve
from sklearn.metrics import f1_score
from sklearn.metrics import auc
from sklearn.metrics import roc_curve
y_pred=model.predict(X_test)
fpr = {}
tpr = {}
thresh ={}
n_class = 4
aucs = []
for i in range(n_class):
    fpr[i], tpr[i], thresh[i] = roc_curve(y_test, y_pred[:,i], pos_label=i)
from random import randint
colors = []
for i in range(6):
    colors.append('#%06X' % randint(0, 0xFFFFFF))
for i in range(n_class):
    num=i
    #plt.plot(fpr[i], tpr[i], linestyle='--',color=colors[i], label='Class %i vs Rest' %num)

    roc_auc = auc(fpr[i], tpr[i])
    aucs.append(roc_auc)
    plt.plot(fpr[i], tpr[i],linestyle='-',color=colors[i], label=  'Class %d (AUC = %0.2f)' % (i, roc_auc))
    i= i+1

    plt.plot([0,1],[0,1],linestyle = '--',color = 'black')
    plt.title('ROC/AUC curve')
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive rate')
    plt.legend(loc="lower right")
plt.show()